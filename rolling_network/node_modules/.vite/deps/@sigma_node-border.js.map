{
  "version": 3,
  "sources": ["../../../../node_modules/sigma/rendering/dist/sigma-rendering.esm.js", "../../../../node_modules/sigma/utils/dist/sigma-utils.esm.js", "../../../../node_modules/@sigma/node-border/dist/sigma-node-border.esm.js"],
  "sourcesContent": ["import { f as NodeProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, _ as _objectSpread2, F as FRAGMENT_SHADER_SOURCE$3, g as EdgeProgram, h as createEdgeCompoundProgram, i as createEdgeArrowHeadProgram } from '../../dist/index-236c62ad.esm.js';\nexport { k as AbstractEdgeProgram, A as AbstractNodeProgram, l as AbstractProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, p as DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS, m as EdgeArrowHeadProgram, E as EdgeArrowProgram, n as EdgeClampedProgram, g as EdgeProgram, e as EdgeRectangleProgram, N as NodeCircleProgram, f as NodeProgram, P as Program, i as createEdgeArrowHeadProgram, q as createEdgeArrowProgram, o as createEdgeClampedProgram, h as createEdgeCompoundProgram, j as createNodeCompoundProgram, c as drawDiscNodeHover, b as drawDiscNodeLabel, d as drawStraightEdgeLabel, r as getAttributeItemsCount, s as getAttributesItemsCount, w as killProgram, u as loadFragmentShader, v as loadProgram, t as loadVertexShader, x as numberToGLSLFloat } from '../../dist/index-236c62ad.esm.js';\nimport { _ as _inherits, a as _createClass, b as _classCallCheck, c as _callSuper } from '../../dist/inherits-d1a1e29b.esm.js';\nimport { f as floatColor } from '../../dist/colors-beb06eb2.esm.js';\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > v_border)\\n    gl_FragColor = v_color;\\n  else\\n    gl_FragColor = transparent;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  gl_FragColor = mix(transparent, v_color, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\n\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\\n\\n  v_border = (0.5 / a_size) * u_sizeRatio;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\n\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$3 = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"];\nvar NodePointProgram = /*#__PURE__*/function (_NodeProgram) {\n  function NodePointProgram() {\n    _classCallCheck(this, NodePointProgram);\n    return _callSuper(this, NodePointProgram, arguments);\n  }\n  _inherits(NodePointProgram, _NodeProgram);\n  return _createClass(NodePointProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 1,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.POINTS,\n        UNIFORMS: UNIFORMS$3,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = floatColor(data.color);\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(_ref, _ref2) {\n      var sizeRatio = _ref.sizeRatio,\n        pixelRatio = _ref.pixelRatio,\n        matrix = _ref.matrix;\n      var gl = _ref2.gl,\n        uniformLocations = _ref2.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_pixelRatio = uniformLocations.u_pixelRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_pixelRatio, pixelRatio);\n      gl.uniform1f(u_sizeRatio, sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, matrix);\n    }\n  }]);\n}(NodeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_sourceRadius;\\nattribute float a_targetRadius;\\nattribute float a_sourceRadiusCoef;\\nattribute float a_targetRadiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow heads:\\n  // Source arrow head\\n  float sourceRadius = a_sourceRadius * a_sourceRadiusCoef;\\n  float sourceDirection = sign(sourceRadius);\\n  float webGLSourceRadius = sourceDirection * sourceRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLSourceArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 sourceCompensationVector =\\n    vec2(-sourceDirection * unitNormal.y, sourceDirection * unitNormal.x)\\n    * (webGLSourceRadius + webGLSourceArrowHeadLength);\\n    \\n  // Target arrow head\\n  float targetRadius = a_targetRadius * a_targetRadiusCoef;\\n  float targetDirection = sign(targetRadius);\\n  float webGLTargetRadius = targetDirection * targetRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLTargetArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 targetCompensationVector =\\n  vec2(-targetDirection * unitNormal.y, targetDirection * unitNormal.x)\\n    * (webGLTargetRadius + webGLTargetArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + sourceCompensationVector + targetCompensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$4;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$2 = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\"];\nvar DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS = {\n  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio\n};\nfunction createEdgeDoubleClampedProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeDoubleClampedProgram() {\n      _classCallCheck(this, EdgeDoubleClampedProgram);\n      return _callSuper(this, EdgeDoubleClampedProgram, arguments);\n    }\n    _inherits(EdgeDoubleClampedProgram, _EdgeProgram);\n    return _createClass(EdgeDoubleClampedProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$3,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$2,\n          ATTRIBUTES: [{\n            name: \"a_positionStart\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_positionEnd\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_sourceRadius\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadius\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_ATTRIBUTES: [\n          // If 0, then position will be a_positionStart\n          // If 1, then position will be a_positionEnd\n          {\n            name: \"a_positionCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_normalCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_sourceRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_DATA: [[0, 1, -1, 0], [0, -1, 1, 0], [1, 1, 0, 1], [1, 1, 0, 1], [0, -1, 1, 0], [1, -1, 0, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = floatColor(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var sourceRadius = sourceData.size || 1;\n        var targetRadius = targetData.size || 1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = n1;\n        array[startIndex++] = n2;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n        array[startIndex++] = sourceRadius;\n        array[startIndex++] = targetRadius;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref) {\n        var gl = _ref.gl,\n          uniformLocations = _ref.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_zoomRatio = uniformLocations.u_zoomRatio,\n          u_feather = uniformLocations.u_feather,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_zoomRatio, params.zoomRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeDoubleClampedProgram = createEdgeDoubleClampedProgram();\nvar EdgeDoubleClampedProgram$1 = EdgeDoubleClampedProgram;\n\nfunction createEdgeDoubleArrowProgram(inputOptions) {\n  return createEdgeCompoundProgram([createEdgeDoubleClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions), createEdgeArrowHeadProgram(_objectSpread2(_objectSpread2({}, inputOptions), {}, {\n    extremity: \"source\"\n  }))]);\n}\nvar EdgeDoubleArrowProgram = createEdgeDoubleArrowProgram();\nvar EdgeDoubleArrowProgram$1 = EdgeDoubleArrowProgram;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$3;\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\n\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  // Scale from [[-1 1] [-1 1]] to the container:\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$2;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\"];\nvar EdgeLineProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeLineProgram() {\n    _classCallCheck(this, EdgeLineProgram);\n    return _callSuper(this, EdgeLineProgram, arguments);\n  }\n  _inherits(EdgeLineProgram, _EdgeProgram);\n  return _createClass(EdgeLineProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 2,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.LINES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var array = this.array;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n\n      // Second point\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n}(EdgeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$1;\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  // The only different here with edge.vert.glsl is that we need to handle null\\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\\n  // on how it works:\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n  if (normalLength <= 0.0) unitNormal = normal;\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_minEdgeThickness\"];\nvar EdgeTriangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeTriangleProgram() {\n    _classCallCheck(this, EdgeTriangleProgram);\n    return _callSuper(this, EdgeTriangleProgram, arguments);\n  }\n  _inherits(EdgeTriangleProgram, _EdgeProgram);\n  return _createClass(EdgeTriangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 0]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n    }\n  }]);\n}(EdgeProgram);\n\nexport { DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS, EdgeDoubleArrowProgram$1 as EdgeDoubleArrowProgram, EdgeDoubleClampedProgram$1 as EdgeDoubleClampedProgram, EdgeLineProgram, EdgeTriangleProgram, NodePointProgram, createEdgeDoubleArrowProgram, createEdgeDoubleClampedProgram };\n", "export { A as ANIMATE_DEFAULTS, h as animateNodes, b as createElement, c as createNormalizationFunction, o as cubicIn, r as cubicInOut, p as cubicOut, e as easings, j as getCorrectionRatio, a as getMatrixImpact, d as getPixelRatio, g as graphExtent, i as identity, l as linear, m as matrixFromCamera, w as multiply, f as multiplyVec2, q as quadraticIn, n as quadraticInOut, k as quadraticOut, t as rotate, s as scale, u as translate, v as validateGraph, z as zIndexOrdering } from '../../dist/normalization-be445518.esm.js';\nexport { H as HTML_COLORS, d as colorToArray, c as colorToIndex, e as extractPixel, f as floatColor, g as getPixelColor, i as indexToColor, p as parseColor, r as rgbaToFloat } from '../../dist/colors-beb06eb2.esm.js';\nexport { a as assign, b as assignDeep, e as extend, i as isPlainObject } from '../../dist/data-11df7124.esm.js';\nimport 'graphology-utils/is-graph';\n", "import { numberToGLSLFloat, NodeProgram } from 'sigma/rendering';\nimport { floatColor, colorToArray } from 'sigma/utils';\n\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\n\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\n\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\n\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\n\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\n\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nvar DEFAULT_BORDER_SIZE_MODE = \"relative\";\nvar DEFAULT_CREATE_NODE_BORDER_OPTIONS = {\n  drawLabel: undefined,\n  drawHover: undefined,\n  borders: [{\n    size: {\n      value: 0.1\n    },\n    color: {\n      attribute: \"borderColor\"\n    }\n  }, {\n    size: {\n      fill: true\n    },\n    color: {\n      attribute: \"color\"\n    }\n  }]\n};\nvar DEFAULT_COLOR = \"#000000\";\n\nfunction getFragmentShader(_ref) {\n  var borders = _ref.borders;\n  var fillCounts = numberToGLSLFloat(borders.filter(function (_ref2) {\n    var size = _ref2.size;\n    return \"fill\" in size;\n  }).length);\n\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\n\\n#ifdef PICKING_MODE\\nvarying vec4 v_color;\\n#else\\n// For normal mode, we use the border colors defined in the program:\\n\".concat(borders.flatMap(function (_ref3, i) {\n    var size = _ref3.size;\n    return \"attribute\" in size ? [\"varying float v_borderSize_\".concat(i + 1, \";\")] : [];\n  }).join(\"\\n\"), \"\\n\").concat(borders.flatMap(function (_ref4, i) {\n    var color = _ref4.color;\n    return \"attribute\" in color ? [\"varying vec4 v_borderColor_\".concat(i + 1, \";\")] : \"value\" in color ? [\"uniform vec4 u_borderColor_\".concat(i + 1, \";\")] : [];\n  }).join(\"\\n\"), \"\\n#endif\\n\\nuniform float u_correctionRatio;\\n\\nconst float bias = 255.0 / 254.0;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float dist = length(v_diffVector);\\n  float aaBorder = 2.0 * u_correctionRatio;\\n  float v_borderSize_0 = v_radius;\\n  vec4 v_borderColor_0 = transparent;\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > v_radius)\\n    gl_FragColor = transparent;\\n  else {\\n    gl_FragColor = v_color;\\n    gl_FragColor.a *= bias;\\n  }\\n  #else\\n  // Sizes:\\n\").concat(borders.flatMap(function (_ref5, i) {\n    var size = _ref5.size;\n    if (\"fill\" in size) return [];\n    size = size;\n    var value = \"attribute\" in size ? \"v_borderSize_\".concat(i + 1) : numberToGLSLFloat(size.value);\n    var factor = (size.mode || DEFAULT_BORDER_SIZE_MODE) === \"pixels\" ? \"u_correctionRatio\" : \"v_radius\";\n    return [\"  float borderSize_\".concat(i + 1, \" = \").concat(factor, \" * \").concat(value, \";\")];\n  }).join(\"\\n\"), \"\\n  // Now, let's split the remaining space between \\\"fill\\\" borders:\\n  float fillBorderSize = (v_radius - (\").concat(borders.flatMap(function (_ref6, i) {\n    var size = _ref6.size;\n    return !(\"fill\" in size) ? [\"borderSize_\".concat(i + 1)] : [];\n  }).join(\" + \"), \") ) / \").concat(fillCounts, \";\\n\").concat(borders.flatMap(function (_ref7, i) {\n    var size = _ref7.size;\n    return \"fill\" in size ? [\"  float borderSize_\".concat(i + 1, \" = fillBorderSize;\")] : [];\n  }).join(\"\\n\"), \"\\n\\n  // Finally, normalize all border sizes, to start from the full size and to end with the smallest:\\n  float adjustedBorderSize_0 = v_radius;\\n\").concat(borders.map(function (_, i) {\n    return \"  float adjustedBorderSize_\".concat(i + 1, \" = adjustedBorderSize_\").concat(i, \" - borderSize_\").concat(i + 1, \";\");\n  }).join(\"\\n\"), \"\\n\\n  // Colors:\\n  vec4 borderColor_0 = transparent;\\n\").concat(borders.map(function (_ref8, i) {\n    var color = _ref8.color;\n    var res = [];\n    if (\"attribute\" in color) {\n      res.push(\"  vec4 borderColor_\".concat(i + 1, \" = v_borderColor_\").concat(i + 1, \";\"));\n    } else if (\"transparent\" in color) {\n      res.push(\"  vec4 borderColor_\".concat(i + 1, \" = vec4(0.0, 0.0, 0.0, 0.0);\"));\n    } else {\n      res.push(\"  vec4 borderColor_\".concat(i + 1, \" = u_borderColor_\").concat(i + 1, \";\"));\n    }\n    res.push(\"  borderColor_\".concat(i + 1, \".a *= bias;\"));\n    res.push(\"  if (borderSize_\".concat(i + 1, \" <= 1.0 * u_correctionRatio) { borderColor_\").concat(i + 1, \" = borderColor_\").concat(i, \"; }\"));\n    return res.join(\"\\n\");\n  }).join(\"\\n\"), \"\\n  if (dist > adjustedBorderSize_0) {\\n    gl_FragColor = borderColor_0;\\n  } else \").concat(borders.map(function (_, i) {\n    return \"if (dist > adjustedBorderSize_\".concat(i, \" - aaBorder) {\\n    gl_FragColor = mix(borderColor_\").concat(i + 1, \", borderColor_\").concat(i, \", (dist - adjustedBorderSize_\").concat(i, \" + aaBorder) / aaBorder);\\n  } else if (dist > adjustedBorderSize_\").concat(i + 1, \") {\\n    gl_FragColor = borderColor_\").concat(i + 1, \";\\n  } else \");\n  }).join(\"\"), \" { /* Nothing to add here */ }\\n  #endif\\n}\\n\");\n  return SHADER;\n}\n\nfunction getVertexShader(_ref) {\n  var borders = _ref.borders;\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nattribute vec2 a_position;\\nattribute float a_size;\\nattribute float a_angle;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\n\\n#ifdef PICKING_MODE\\nattribute vec4 a_id;\\nvarying vec4 v_color;\\n#else\\n\".concat(borders.flatMap(function (_ref2, i) {\n    var size = _ref2.size;\n    return \"attribute\" in size ? [\"attribute float a_borderSize_\".concat(i + 1, \";\"), \"varying float v_borderSize_\".concat(i + 1, \";\")] : [];\n  }).join(\"\\n\"), \"\\n\").concat(borders.flatMap(function (_ref3, i) {\n    var color = _ref3.color;\n    return \"attribute\" in color ? [\"attribute vec4 a_borderColor_\".concat(i + 1, \";\"), \"varying vec4 v_borderColor_\".concat(i + 1, \";\")] : [];\n  }).join(\"\\n\"), \"\\n#endif\\n\\nconst float bias = 255.0 / 254.0;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main() {\\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\\n  vec2 position = a_position + diffVector;\\n  gl_Position = vec4(\\n    (u_matrix * vec3(position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  v_radius = size / 2.0;\\n  v_diffVector = diffVector;\\n\\n  #ifdef PICKING_MODE\\n  v_color = a_id;\\n  #else\\n\").concat(borders.flatMap(function (_ref4, i) {\n    var size = _ref4.size;\n    return \"attribute\" in size ? [\"  v_borderSize_\".concat(i + 1, \" = a_borderSize_\").concat(i + 1, \";\")] : [];\n  }).join(\"\\n\"), \"\\n\").concat(borders.flatMap(function (_ref5, i) {\n    var color = _ref5.color;\n    return \"attribute\" in color ? [\"  v_borderColor_\".concat(i + 1, \" = a_borderColor_\").concat(i + 1, \";\")] : [];\n  }).join(\"\\n\"), \"\\n  #endif\\n}\\n\");\n  return SHADER;\n}\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nfunction createNodeBorderProgram(inputOptions) {\n  var _NodeBorderProgram;\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_CREATE_NODE_BORDER_OPTIONS), inputOptions || {});\n  var borders = options.borders,\n    drawLabel = options.drawLabel,\n    drawHover = options.drawHover;\n  var UNIFORMS = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_matrix\"].concat(_toConsumableArray(borders.flatMap(function (_ref, i) {\n    var color = _ref.color;\n    return \"value\" in color ? [\"u_borderColor_\".concat(i + 1)] : [];\n  })));\n  return _NodeBorderProgram = /*#__PURE__*/function (_NodeProgram) {\n    _inherits(NodeBorderProgram, _NodeProgram);\n    function NodeBorderProgram() {\n      var _this;\n      _classCallCheck(this, NodeBorderProgram);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, NodeBorderProgram, [].concat(args));\n      _defineProperty(_assertThisInitialized(_this), \"drawLabel\", drawLabel);\n      _defineProperty(_assertThisInitialized(_this), \"drawHover\", drawHover);\n      return _this;\n    }\n    _createClass(NodeBorderProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 3,\n          VERTEX_SHADER_SOURCE: getVertexShader(options),\n          FRAGMENT_SHADER_SOURCE: getFragmentShader(options),\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS,\n          ATTRIBUTES: [{\n            name: \"a_position\",\n            size: 2,\n            type: FLOAT\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }, {\n            name: \"a_size\",\n            size: 1,\n            type: FLOAT\n          }].concat(_toConsumableArray(borders.flatMap(function (_ref2, i) {\n            var color = _ref2.color;\n            return \"attribute\" in color ? [{\n              name: \"a_borderColor_\".concat(i + 1),\n              size: 4,\n              type: UNSIGNED_BYTE,\n              normalized: true\n            }] : [];\n          })), _toConsumableArray(borders.flatMap(function (_ref3, i) {\n            var size = _ref3.size;\n            return \"attribute\" in size ? [{\n              name: \"a_borderSize_\".concat(i + 1),\n              size: 1,\n              type: FLOAT\n            }] : [];\n          }))),\n          CONSTANT_ATTRIBUTES: [{\n            name: \"a_angle\",\n            size: 1,\n            type: FLOAT\n          }],\n          CONSTANT_DATA: [[NodeBorderProgram.ANGLE_1], [NodeBorderProgram.ANGLE_2], [NodeBorderProgram.ANGLE_3]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(nodeIndex, startIndex, data) {\n        var array = this.array;\n        array[startIndex++] = data.x;\n        array[startIndex++] = data.y;\n        array[startIndex++] = nodeIndex;\n        array[startIndex++] = data.size;\n        borders.forEach(function (_ref4) {\n          var color = _ref4.color;\n          if (\"attribute\" in color) array[startIndex++] = floatColor(data[color.attribute] || color.defaultValue || DEFAULT_COLOR);\n        });\n        borders.forEach(function (_ref5) {\n          var size = _ref5.size;\n          if (\"attribute\" in size) array[startIndex++] = data[size.attribute] || size.defaultValue;\n        });\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref6) {\n        var gl = _ref6.gl,\n          uniformLocations = _ref6.uniformLocations;\n        var u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_matrix = uniformLocations.u_matrix;\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        borders.forEach(function (_ref7, i) {\n          var color = _ref7.color;\n          if (\"value\" in color) {\n            var location = uniformLocations[\"u_borderColor_\".concat(i + 1)];\n            var _colorToArray = colorToArray(color.value),\n              _colorToArray2 = _slicedToArray(_colorToArray, 4),\n              r = _colorToArray2[0],\n              g = _colorToArray2[1],\n              b = _colorToArray2[2],\n              a = _colorToArray2[3];\n            gl.uniform4f(location, r / 255, g / 255, b / 255, a / 255);\n          }\n        });\n      }\n    }]);\n    return NodeBorderProgram;\n  }(NodeProgram), _defineProperty(_NodeBorderProgram, \"ANGLE_1\", 0), _defineProperty(_NodeBorderProgram, \"ANGLE_2\", 2 * Math.PI / 3), _defineProperty(_NodeBorderProgram, \"ANGLE_3\", 4 * Math.PI / 3), _NodeBorderProgram;\n}\n\nvar NodeBorderProgram = createNodeBorderProgram();\n\nexport { NodeBorderProgram, createNodeBorderProgram };\n"],
  "mappings": "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",
  "names": ["NodePointProgram", "EdgeDoubleClampedProgram", "EdgeLineProgram", "FRAGMENT_SHADER_SOURCE", "EdgeTriangleProgram", "r", "_classCallCheck", "_createClass", "t", "_callSuper", "e", "_inherits", "_objectSpread2", "_WebGLRenderingContex", "UNSIGNED_BYTE", "FLOAT", "UNIFORMS", "NodeBorderProgram"]
}
